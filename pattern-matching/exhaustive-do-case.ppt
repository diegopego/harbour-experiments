exhaustive-do-case.prg(24) >CLASS STRING<
#xcommand >_HB_CLASS STRING ; function __HB_CLS_OPT( STRING ) ( HB_CLS_PARAM_LIST ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := HB_OO_CLSTP_EXPORTED ; HB_SYMBOL_UNUSED( nScope ) ; oClass := iif( .F.,, HBClass():new( "STRING", __HB_CLS_PAR( ), @__HB_CLS_OPT( STRING)() ) ) ; #undef _CLASS_NAME_ ; #define _CLASS_NAME_ STRING ; #undef _CLASS_MODE_ ; #define _CLASS_MODE_ _CLASS_DECLARATION_<
exhaustive-do-case.prg(24) >HB_CLS_PARAM_LIST<
#define >...<
exhaustive-do-case.prg(24) >HB_OO_CLSTP_EXPORTED<
#define >1<
exhaustive-do-case.prg(24) >HB_SYMBOL_UNUSED( nScope )<
#define >( ( nScope ) )<
exhaustive-do-case.prg(24) >__HB_CLS_OPT( STRING )<
#xtranslate >STRING<
exhaustive-do-case.prg(24) >__HB_CLS_PAR( )<
#xtranslate >iif( .F., { }, { @HBObject() } )<
exhaustive-do-case.prg(24) >__HB_CLS_OPT( STRING)<
#xtranslate >STRING<
exhaustive-do-case.prg(25) >method type()<
#xcommand >METHOD type() _CLASS_MODE_<
exhaustive-do-case.prg(25) >_CLASS_MODE_<
#define >_CLASS_DECLARATION_<
exhaustive-do-case.prg(25) >METHOD type() _CLASS_DECLARATION_<
#xcommand >_HB_MEMBER __HB_CLS_ASFUNC(type()); __HB_CLS_DECLARE_METHOD __HB_CLS_PARAMS(type()) _CLASS_NAME_ ; oClass:AddMethod( __HB_CLS_ASSTRING(type()), @__HB_CLS_ASID( __HB_CLS_MTHNAME _CLASS_NAME_ type() )(), __HB_CLS_SCOPE( .F., .F., .F. ) + iif( .F., HB_OO_CLSTP_CTOR, 0 ) + iif( .F., HB_OO_CLSTP_PERSIST, 0 ) + iif( .F., HB_OO_CLSTP_SYNC, 0 ) )<
exhaustive-do-case.prg(25) >_CLASS_NAME_<
#define >STRING<
exhaustive-do-case.prg(25) >_CLASS_NAME_<
#define >STRING<
exhaustive-do-case.prg(25) >HB_OO_CLSTP_CTOR<
#define >8<
exhaustive-do-case.prg(25) >HB_OO_CLSTP_PERSIST<
#define >256<
exhaustive-do-case.prg(25) >HB_OO_CLSTP_SYNC<
#define >2048<
exhaustive-do-case.prg(25) >__HB_CLS_ASFUNC(type())<
#xtranslate >type()<
exhaustive-do-case.prg(25) >__HB_CLS_PARAMS(type())<
#xtranslate >type()<
exhaustive-do-case.prg(25) >__HB_CLS_ASSTRING(type())<
#xtranslate >"type"<
exhaustive-do-case.prg(25) >__HB_CLS_MTHNAME STRING type()<
#xtranslate >STRING_type()<
exhaustive-do-case.prg(25) >__HB_CLS_SCOPE( .F., .F., .F. )<
#xtranslate >nScope<
exhaustive-do-case.prg(25) >STRING _<
(concatenate) >STRING_<
exhaustive-do-case.prg(25) >STRING_ type<
(concatenate) >STRING_type<
exhaustive-do-case.prg(25) >__HB_CLS_ASID( STRING_type() )<
#xtranslate >STRING_type<
exhaustive-do-case.prg(25) >__HB_CLS_DECLARE_METHOD type() STRING<
#xcommand >#xcommand METHOD <type: FUNCTION, PROCEDURE> type() CLASS STRING _CLASS_IMPLEMENTATION_ => DECLARED METHOD <type> type() CLASS STRING<
exhaustive-do-case.prg(26) >ENDCLASS<
#xcommand >oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; END SEQUENCE ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( HB_CLS_PARAM_LIST ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS _CLASS_NAME_ ; #undef _CLASS_MODE_ ; #define _CLASS_MODE_ _CLASS_IMPLEMENTATION_<
exhaustive-do-case.prg(26) >HB_CLS_PARAM_LIST<
#define >...<
exhaustive-do-case.prg(26) >_CLASS_NAME_<
#define >STRING<
exhaustive-do-case.prg(26) >END SEQUENCE<
#command >end<
exhaustive-do-case.prg(28) >method type() class STRING<
#xcommand >METHOD FUNCTION type() CLASS STRING _CLASS_MODE_<
exhaustive-do-case.prg(28) >_CLASS_MODE_<
#define >_CLASS_IMPLEMENTATION_<
exhaustive-do-case.prg(28) >METHOD FUNCTION type() CLASS STRING _CLASS_IMPLEMENTATION_<
#xcommand >DECLARED METHOD FUNCTION type() CLASS STRING<
exhaustive-do-case.prg(28) >DECLARED METHOD FUNCTION type() CLASS STRING<
#xcommand >static FUNCTION __HB_CLS_MTHNAME STRING type() ; local Self AS CLASS STRING := QSelf() AS CLASS STRING<
exhaustive-do-case.prg(28) >__HB_CLS_MTHNAME STRING type()<
#xtranslate >STRING_type()<
exhaustive-do-case.prg(28) >STRING _<
(concatenate) >STRING_<
exhaustive-do-case.prg(28) >STRING_ type<
(concatenate) >STRING_type<
exhaustive-do-case.prg(47) >type USAddress = Street of STRING, City of STRING<
#xcommand >CLASS USAddress; METHOD New() ; method type(); data fields ; ENDCLASS; method New() class USAddress; ::fields := {"fields" => {"field" => "Street", "type" => STRING():new():type()}}; return self; method type() class USAddress; return upper("USAddress")<
exhaustive-do-case.prg(47) >CLASS USAddress<
#xcommand >_HB_CLASS USAddress ; function __HB_CLS_OPT( USAddress ) ( HB_CLS_PARAM_LIST ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := HB_OO_CLSTP_EXPORTED ; HB_SYMBOL_UNUSED( nScope ) ; oClass := iif( .F.,, HBClass():new( "USAddress", __HB_CLS_PAR( ), @__HB_CLS_OPT( USAddress)() ) ) ; #undef _CLASS_NAME_ ; #define _CLASS_NAME_ USAddress ; #undef _CLASS_MODE_ ; #define _CLASS_MODE_ _CLASS_DECLARATION_<
exhaustive-do-case.prg(47) >HB_CLS_PARAM_LIST<
#define >...<
exhaustive-do-case.prg(47) >HB_OO_CLSTP_EXPORTED<
#define >1<
exhaustive-do-case.prg(47) >HB_SYMBOL_UNUSED( nScope )<
#define >( ( nScope ) )<
exhaustive-do-case.prg(47) >__HB_CLS_OPT( USAddress )<
#xtranslate >USAddress<
exhaustive-do-case.prg(47) >__HB_CLS_PAR( )<
#xtranslate >iif( .F., { }, { @HBObject() } )<
exhaustive-do-case.prg(47) >__HB_CLS_OPT( USAddress)<
#xtranslate >USAddress<
exhaustive-do-case.prg(47) >METHOD New()<
#xcommand >METHOD New() _CLASS_MODE_<
exhaustive-do-case.prg(47) >_CLASS_MODE_<
#define >_CLASS_DECLARATION_<
exhaustive-do-case.prg(47) >METHOD New() _CLASS_DECLARATION_<
#xcommand >_HB_MEMBER __HB_CLS_ASFUNC(New()); __HB_CLS_DECLARE_METHOD __HB_CLS_PARAMS(New()) _CLASS_NAME_ ; oClass:AddMethod( __HB_CLS_ASSTRING(New()), @__HB_CLS_ASID( __HB_CLS_MTHNAME _CLASS_NAME_ New() )(), __HB_CLS_SCOPE( .F., .F., .F. ) + iif( .F., HB_OO_CLSTP_CTOR, 0 ) + iif( .F., HB_OO_CLSTP_PERSIST, 0 ) + iif( .F., HB_OO_CLSTP_SYNC, 0 ) )<
exhaustive-do-case.prg(47) >_CLASS_NAME_<
#define >USAddress<
exhaustive-do-case.prg(47) >_CLASS_NAME_<
#define >USAddress<
exhaustive-do-case.prg(47) >HB_OO_CLSTP_CTOR<
#define >8<
exhaustive-do-case.prg(47) >HB_OO_CLSTP_PERSIST<
#define >256<
exhaustive-do-case.prg(47) >HB_OO_CLSTP_SYNC<
#define >2048<
exhaustive-do-case.prg(47) >__HB_CLS_ASFUNC(New())<
#xtranslate >New()<
exhaustive-do-case.prg(47) >__HB_CLS_PARAMS(New())<
#xtranslate >New()<
exhaustive-do-case.prg(47) >__HB_CLS_ASSTRING(New())<
#xtranslate >"New"<
exhaustive-do-case.prg(47) >__HB_CLS_MTHNAME USAddress New()<
#xtranslate >USAddress_New()<
exhaustive-do-case.prg(47) >__HB_CLS_SCOPE( .F., .F., .F. )<
#xtranslate >nScope<
exhaustive-do-case.prg(47) >USAddress _<
(concatenate) >USAddress_<
exhaustive-do-case.prg(47) >USAddress_ New<
(concatenate) >USAddress_New<
exhaustive-do-case.prg(47) >__HB_CLS_ASID( USAddress_New() )<
#xtranslate >USAddress_New<
exhaustive-do-case.prg(47) >__HB_CLS_DECLARE_METHOD New() USAddress<
#xcommand >#xcommand METHOD <type: FUNCTION, PROCEDURE> New() CLASS USAddress _CLASS_IMPLEMENTATION_ => DECLARED METHOD <type> New() CLASS USAddress<
exhaustive-do-case.prg(47) >method type()<
#xcommand >METHOD type() _CLASS_MODE_<
exhaustive-do-case.prg(47) >_CLASS_MODE_<
#define >_CLASS_DECLARATION_<
exhaustive-do-case.prg(47) >METHOD type() _CLASS_DECLARATION_<
#xcommand >_HB_MEMBER __HB_CLS_ASFUNC(type()); __HB_CLS_DECLARE_METHOD __HB_CLS_PARAMS(type()) _CLASS_NAME_ ; oClass:AddMethod( __HB_CLS_ASSTRING(type()), @__HB_CLS_ASID( __HB_CLS_MTHNAME _CLASS_NAME_ type() )(), __HB_CLS_SCOPE( .F., .F., .F. ) + iif( .F., HB_OO_CLSTP_CTOR, 0 ) + iif( .F., HB_OO_CLSTP_PERSIST, 0 ) + iif( .F., HB_OO_CLSTP_SYNC, 0 ) )<
exhaustive-do-case.prg(47) >_CLASS_NAME_<
#define >USAddress<
exhaustive-do-case.prg(47) >_CLASS_NAME_<
#define >USAddress<
exhaustive-do-case.prg(47) >HB_OO_CLSTP_CTOR<
#define >8<
exhaustive-do-case.prg(47) >HB_OO_CLSTP_PERSIST<
#define >256<
exhaustive-do-case.prg(47) >HB_OO_CLSTP_SYNC<
#define >2048<
exhaustive-do-case.prg(47) >__HB_CLS_ASFUNC(type())<
#xtranslate >type()<
exhaustive-do-case.prg(47) >__HB_CLS_PARAMS(type())<
#xtranslate >type()<
exhaustive-do-case.prg(47) >__HB_CLS_ASSTRING(type())<
#xtranslate >"type"<
exhaustive-do-case.prg(47) >__HB_CLS_MTHNAME USAddress type()<
#xtranslate >USAddress_type()<
exhaustive-do-case.prg(47) >__HB_CLS_SCOPE( .F., .F., .F. )<
#xtranslate >nScope<
exhaustive-do-case.prg(47) >USAddress _<
(concatenate) >USAddress_<
exhaustive-do-case.prg(47) >USAddress_ type<
(concatenate) >USAddress_type<
exhaustive-do-case.prg(47) >__HB_CLS_ASID( USAddress_type() )<
#xtranslate >USAddress_type<
exhaustive-do-case.prg(47) >__HB_CLS_DECLARE_METHOD type() USAddress<
#xcommand >#xcommand METHOD <type: FUNCTION, PROCEDURE> type() CLASS USAddress _CLASS_IMPLEMENTATION_ => DECLARED METHOD <type> type() CLASS USAddress<
exhaustive-do-case.prg(47) >data fields<
#xcommand >_HB_MEMBER { fields } ; oClass:AddMultiData(,, __HB_CLS_SCOPE( .F., .F., .F. ) + iif( .F., HB_OO_CLSTP_READONLY, 0 ) + iif( .F., HB_OO_CLSTP_PERSIST, 0 ) + iif( .F., HB_OO_CLSTP_SYNC, 0 ), {"fields"}, __HB_CLS_NOINI )<
exhaustive-do-case.prg(47) >HB_OO_CLSTP_READONLY<
#define >16<
exhaustive-do-case.prg(47) >HB_OO_CLSTP_PERSIST<
#define >256<
exhaustive-do-case.prg(47) >HB_OO_CLSTP_SYNC<
#define >2048<
exhaustive-do-case.prg(47) >__HB_CLS_NOINI<
#define >.F.<
exhaustive-do-case.prg(47) >__HB_CLS_SCOPE( .F., .F., .F. )<
#xtranslate >nScope<
exhaustive-do-case.prg(47) >ENDCLASS<
#xcommand >oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; END SEQUENCE ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( HB_CLS_PARAM_LIST ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS _CLASS_NAME_ ; #undef _CLASS_MODE_ ; #define _CLASS_MODE_ _CLASS_IMPLEMENTATION_<
exhaustive-do-case.prg(47) >HB_CLS_PARAM_LIST<
#define >...<
exhaustive-do-case.prg(47) >_CLASS_NAME_<
#define >USAddress<
exhaustive-do-case.prg(47) >END SEQUENCE<
#command >end<
exhaustive-do-case.prg(47) >method New() class USAddress<
#xcommand >METHOD FUNCTION New() CLASS USAddress _CLASS_MODE_<
exhaustive-do-case.prg(47) >_CLASS_MODE_<
#define >_CLASS_IMPLEMENTATION_<
exhaustive-do-case.prg(47) >METHOD FUNCTION New() CLASS USAddress _CLASS_IMPLEMENTATION_<
#xcommand >DECLARED METHOD FUNCTION New() CLASS USAddress<
exhaustive-do-case.prg(47) >DECLARED METHOD FUNCTION New() CLASS USAddress<
#xcommand >static FUNCTION __HB_CLS_MTHNAME USAddress New() ; local Self AS CLASS USAddress := QSelf() AS CLASS USAddress<
exhaustive-do-case.prg(47) >__HB_CLS_MTHNAME USAddress New()<
#xtranslate >USAddress_New()<
exhaustive-do-case.prg(47) >USAddress _<
(concatenate) >USAddress_<
exhaustive-do-case.prg(47) >USAddress_ New<
(concatenate) >USAddress_New<
exhaustive-do-case.prg(47) >method type() class USAddress<
#xcommand >METHOD FUNCTION type() CLASS USAddress _CLASS_MODE_<
exhaustive-do-case.prg(47) >_CLASS_MODE_<
#define >_CLASS_IMPLEMENTATION_<
exhaustive-do-case.prg(47) >METHOD FUNCTION type() CLASS USAddress _CLASS_IMPLEMENTATION_<
#xcommand >DECLARED METHOD FUNCTION type() CLASS USAddress<
exhaustive-do-case.prg(47) >DECLARED METHOD FUNCTION type() CLASS USAddress<
#xcommand >static FUNCTION __HB_CLS_MTHNAME USAddress type() ; local Self AS CLASS USAddress := QSelf() AS CLASS USAddress<
exhaustive-do-case.prg(47) >__HB_CLS_MTHNAME USAddress type()<
#xtranslate >USAddress_type()<
exhaustive-do-case.prg(47) >USAddress _<
(concatenate) >USAddress_<
exhaustive-do-case.prg(47) >USAddress_ type<
(concatenate) >USAddress_type<
exhaustive-do-case.prg(52) >let local address of USAddress<
#xcommand >local address := USAddress():new()<
exhaustive-do-case.prg(53) >? address<
#command >QOut( address )<
exhaustive-do-case.prg(71) >type USAddress = Street of STRING, City of STRING<
#xcommand >CLASS USAddress; METHOD New() ; method type(); data fields ; ENDCLASS; method New() class USAddress; ::fields := {"fields" => {"field" => "Street", "type" => STRING():new():type()}}; return self; method type() class USAddress; return upper("USAddress")<
exhaustive-do-case.prg(71) >CLASS USAddress<
#xcommand >_HB_CLASS USAddress ; function __HB_CLS_OPT( USAddress ) ( HB_CLS_PARAM_LIST ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := HB_OO_CLSTP_EXPORTED ; HB_SYMBOL_UNUSED( nScope ) ; oClass := iif( .F.,, HBClass():new( "USAddress", __HB_CLS_PAR( ), @__HB_CLS_OPT( USAddress)() ) ) ; #undef _CLASS_NAME_ ; #define _CLASS_NAME_ USAddress ; #undef _CLASS_MODE_ ; #define _CLASS_MODE_ _CLASS_DECLARATION_<
exhaustive-do-case.prg(71) >HB_CLS_PARAM_LIST<
#define >...<
exhaustive-do-case.prg(71) >HB_OO_CLSTP_EXPORTED<
#define >1<
exhaustive-do-case.prg(71) >HB_SYMBOL_UNUSED( nScope )<
#define >( ( nScope ) )<
exhaustive-do-case.prg(71) >__HB_CLS_OPT( USAddress )<
#xtranslate >USAddress<
exhaustive-do-case.prg(71) >__HB_CLS_PAR( )<
#xtranslate >iif( .F., { }, { @HBObject() } )<
exhaustive-do-case.prg(71) >__HB_CLS_OPT( USAddress)<
#xtranslate >USAddress<
exhaustive-do-case.prg(71) >METHOD New()<
#xcommand >METHOD New() _CLASS_MODE_<
exhaustive-do-case.prg(71) >_CLASS_MODE_<
#define >_CLASS_DECLARATION_<
exhaustive-do-case.prg(71) >METHOD New() _CLASS_DECLARATION_<
#xcommand >_HB_MEMBER __HB_CLS_ASFUNC(New()); __HB_CLS_DECLARE_METHOD __HB_CLS_PARAMS(New()) _CLASS_NAME_ ; oClass:AddMethod( __HB_CLS_ASSTRING(New()), @__HB_CLS_ASID( __HB_CLS_MTHNAME _CLASS_NAME_ New() )(), __HB_CLS_SCOPE( .F., .F., .F. ) + iif( .F., HB_OO_CLSTP_CTOR, 0 ) + iif( .F., HB_OO_CLSTP_PERSIST, 0 ) + iif( .F., HB_OO_CLSTP_SYNC, 0 ) )<
exhaustive-do-case.prg(71) >_CLASS_NAME_<
#define >USAddress<
exhaustive-do-case.prg(71) >_CLASS_NAME_<
#define >USAddress<
exhaustive-do-case.prg(71) >HB_OO_CLSTP_CTOR<
#define >8<
exhaustive-do-case.prg(71) >HB_OO_CLSTP_PERSIST<
#define >256<
exhaustive-do-case.prg(71) >HB_OO_CLSTP_SYNC<
#define >2048<
exhaustive-do-case.prg(71) >__HB_CLS_ASFUNC(New())<
#xtranslate >New()<
exhaustive-do-case.prg(71) >__HB_CLS_PARAMS(New())<
#xtranslate >New()<
exhaustive-do-case.prg(71) >__HB_CLS_ASSTRING(New())<
#xtranslate >"New"<
exhaustive-do-case.prg(71) >__HB_CLS_MTHNAME USAddress New()<
#xtranslate >USAddress_New()<
exhaustive-do-case.prg(71) >__HB_CLS_SCOPE( .F., .F., .F. )<
#xtranslate >nScope<
exhaustive-do-case.prg(71) >USAddress _<
(concatenate) >USAddress_<
exhaustive-do-case.prg(71) >USAddress_ New<
(concatenate) >USAddress_New<
exhaustive-do-case.prg(71) >__HB_CLS_ASID( USAddress_New() )<
#xtranslate >USAddress_New<
exhaustive-do-case.prg(71) >__HB_CLS_DECLARE_METHOD New() USAddress<
#xcommand >#xcommand METHOD <type: FUNCTION, PROCEDURE> New() CLASS USAddress _CLASS_IMPLEMENTATION_ => DECLARED METHOD <type> New() CLASS USAddress<
exhaustive-do-case.prg(71) >method type()<
#xcommand >METHOD type() _CLASS_MODE_<
exhaustive-do-case.prg(71) >_CLASS_MODE_<
#define >_CLASS_DECLARATION_<
exhaustive-do-case.prg(71) >METHOD type() _CLASS_DECLARATION_<
#xcommand >_HB_MEMBER __HB_CLS_ASFUNC(type()); __HB_CLS_DECLARE_METHOD __HB_CLS_PARAMS(type()) _CLASS_NAME_ ; oClass:AddMethod( __HB_CLS_ASSTRING(type()), @__HB_CLS_ASID( __HB_CLS_MTHNAME _CLASS_NAME_ type() )(), __HB_CLS_SCOPE( .F., .F., .F. ) + iif( .F., HB_OO_CLSTP_CTOR, 0 ) + iif( .F., HB_OO_CLSTP_PERSIST, 0 ) + iif( .F., HB_OO_CLSTP_SYNC, 0 ) )<
exhaustive-do-case.prg(71) >_CLASS_NAME_<
#define >USAddress<
exhaustive-do-case.prg(71) >_CLASS_NAME_<
#define >USAddress<
exhaustive-do-case.prg(71) >HB_OO_CLSTP_CTOR<
#define >8<
exhaustive-do-case.prg(71) >HB_OO_CLSTP_PERSIST<
#define >256<
exhaustive-do-case.prg(71) >HB_OO_CLSTP_SYNC<
#define >2048<
exhaustive-do-case.prg(71) >__HB_CLS_ASFUNC(type())<
#xtranslate >type()<
exhaustive-do-case.prg(71) >__HB_CLS_PARAMS(type())<
#xtranslate >type()<
exhaustive-do-case.prg(71) >__HB_CLS_ASSTRING(type())<
#xtranslate >"type"<
exhaustive-do-case.prg(71) >__HB_CLS_MTHNAME USAddress type()<
#xtranslate >USAddress_type()<
exhaustive-do-case.prg(71) >__HB_CLS_SCOPE( .F., .F., .F. )<
#xtranslate >nScope<
exhaustive-do-case.prg(71) >USAddress _<
(concatenate) >USAddress_<
exhaustive-do-case.prg(71) >USAddress_ type<
(concatenate) >USAddress_type<
exhaustive-do-case.prg(71) >__HB_CLS_ASID( USAddress_type() )<
#xtranslate >USAddress_type<
exhaustive-do-case.prg(71) >__HB_CLS_DECLARE_METHOD type() USAddress<
#xcommand >#xcommand METHOD <type: FUNCTION, PROCEDURE> type() CLASS USAddress _CLASS_IMPLEMENTATION_ => DECLARED METHOD <type> type() CLASS USAddress<
exhaustive-do-case.prg(71) >data fields<
#xcommand >_HB_MEMBER { fields } ; oClass:AddMultiData(,, __HB_CLS_SCOPE( .F., .F., .F. ) + iif( .F., HB_OO_CLSTP_READONLY, 0 ) + iif( .F., HB_OO_CLSTP_PERSIST, 0 ) + iif( .F., HB_OO_CLSTP_SYNC, 0 ), {"fields"}, __HB_CLS_NOINI )<
exhaustive-do-case.prg(71) >HB_OO_CLSTP_READONLY<
#define >16<
exhaustive-do-case.prg(71) >HB_OO_CLSTP_PERSIST<
#define >256<
exhaustive-do-case.prg(71) >HB_OO_CLSTP_SYNC<
#define >2048<
exhaustive-do-case.prg(71) >__HB_CLS_NOINI<
#define >.F.<
exhaustive-do-case.prg(71) >__HB_CLS_SCOPE( .F., .F., .F. )<
#xtranslate >nScope<
exhaustive-do-case.prg(71) >ENDCLASS<
#xcommand >oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; END SEQUENCE ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( HB_CLS_PARAM_LIST ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS _CLASS_NAME_ ; #undef _CLASS_MODE_ ; #define _CLASS_MODE_ _CLASS_IMPLEMENTATION_<
exhaustive-do-case.prg(71) >HB_CLS_PARAM_LIST<
#define >...<
exhaustive-do-case.prg(71) >_CLASS_NAME_<
#define >USAddress<
exhaustive-do-case.prg(71) >END SEQUENCE<
#command >end<
exhaustive-do-case.prg(71) >method New() class USAddress<
#xcommand >METHOD FUNCTION New() CLASS USAddress _CLASS_MODE_<
exhaustive-do-case.prg(71) >_CLASS_MODE_<
#define >_CLASS_IMPLEMENTATION_<
exhaustive-do-case.prg(71) >METHOD FUNCTION New() CLASS USAddress _CLASS_IMPLEMENTATION_<
#xcommand >DECLARED METHOD FUNCTION New() CLASS USAddress<
exhaustive-do-case.prg(71) >DECLARED METHOD FUNCTION New() CLASS USAddress<
#xcommand >static FUNCTION __HB_CLS_MTHNAME USAddress New() ; local Self AS CLASS USAddress := QSelf() AS CLASS USAddress<
exhaustive-do-case.prg(71) >__HB_CLS_MTHNAME USAddress New()<
#xtranslate >USAddress_New()<
exhaustive-do-case.prg(71) >USAddress _<
(concatenate) >USAddress_<
exhaustive-do-case.prg(71) >USAddress_ New<
(concatenate) >USAddress_New<
exhaustive-do-case.prg(71) >method type() class USAddress<
#xcommand >METHOD FUNCTION type() CLASS USAddress _CLASS_MODE_<
exhaustive-do-case.prg(71) >_CLASS_MODE_<
#define >_CLASS_IMPLEMENTATION_<
exhaustive-do-case.prg(71) >METHOD FUNCTION type() CLASS USAddress _CLASS_IMPLEMENTATION_<
#xcommand >DECLARED METHOD FUNCTION type() CLASS USAddress<
exhaustive-do-case.prg(71) >DECLARED METHOD FUNCTION type() CLASS USAddress<
#xcommand >static FUNCTION __HB_CLS_MTHNAME USAddress type() ; local Self AS CLASS USAddress := QSelf() AS CLASS USAddress<
exhaustive-do-case.prg(71) >__HB_CLS_MTHNAME USAddress type()<
#xtranslate >USAddress_type()<
exhaustive-do-case.prg(71) >USAddress _<
(concatenate) >USAddress_<
exhaustive-do-case.prg(71) >USAddress_ type<
(concatenate) >USAddress_type<

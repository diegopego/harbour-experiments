#line 36 "exhaustive-do-case.prg"
_HB_CLASS USAddress ; function USAddress ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "USAddress", iif( .F., { }, { @HBObject() } ), @USAddress() ) ) ; _HB_MEMBER { Street } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"Street"}, .F. ); ;_HB_MEMBER { City } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"City"}, .F. ); _HB_MEMBER New( Street); oClass:AddMethod( "New", @USAddress_New(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) ); oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS USAddress ; static FUNCTION USAddress_New( Street ) ; local Self AS CLASS USAddress := QSelf() AS CLASS USAddress; ::Street := Street; return Self; _HB_CLASS Street ; function Street ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "Street", iif( .F., { }, { @HBObject() } ), @Street() ) ) ; _HB_MEMBER { myProp } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"myProp"}, .F. ); _HB_MEMBER New( myProp); oClass:AddMethod( "New", @Street_New(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) ); oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS Street ; static FUNCTION Street_New( myProp ) ; local Self AS CLASS Street := QSelf() AS CLASS Street; ::myProp := myProp; return Self; ; _HB_CLASS City ; function City ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "City", iif( .F., { }, { @HBObject() } ), @City() ) ) ; _HB_MEMBER { myProp } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"myProp"}, .F. ); _HB_MEMBER New( myProp); oClass:AddMethod( "New", @City_New(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) ); oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS City ; static FUNCTION City_New( myProp ) ; local Self AS CLASS City := QSelf() AS CLASS City; ::myProp := myProp; return Self;;
_HB_CLASS UKAddress ; function UKAddress ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "UKAddress", iif( .F., { }, { @HBObject() } ), @UKAddress() ) ) ; _HB_MEMBER { Street } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"Street"}, .F. ); ;_HB_MEMBER { Town } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"Town"}, .F. ) ;_HB_MEMBER { PostCode } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"PostCode"}, .F. ); _HB_MEMBER New( Street); oClass:AddMethod( "New", @UKAddress_New(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) ); oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS UKAddress ; static FUNCTION UKAddress_New( Street ) ; local Self AS CLASS UKAddress := QSelf() AS CLASS UKAddress; ::Street := Street; return Self; _HB_CLASS Street ; function Street ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "Street", iif( .F., { }, { @HBObject() } ), @Street() ) ) ; _HB_MEMBER { myProp } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"myProp"}, .F. ); _HB_MEMBER New( myProp); oClass:AddMethod( "New", @Street_New(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) ); oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS Street ; static FUNCTION Street_New( myProp ) ; local Self AS CLASS Street := QSelf() AS CLASS Street; ::myProp := myProp; return Self; ; _HB_CLASS Town ; function Town ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "Town", iif( .F., { }, { @HBObject() } ), @Town() ) ) ; _HB_MEMBER { myProp } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"myProp"}, .F. ); _HB_MEMBER New( myProp); oClass:AddMethod( "New", @Town_New(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) ); oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS Town ; static FUNCTION Town_New( myProp ) ; local Self AS CLASS Town := QSelf() AS CLASS Town; ::myProp := myProp; return Self; ; _HB_CLASS PostCode ; function PostCode ( ... ) ; STATIC s_oClass ; LOCAL nScope, oClass, oInstance ; IF s_oClass == NIL .AND. __clsLockDef( @s_oClass ) ; BEGIN SEQUENCE ; nScope := 1 ; ( ( nScope ) ) ; oClass := iif( .F.,, HBClass():new( "PostCode", iif( .F., { }, { @HBObject() } ), @PostCode() ) ) ; _HB_MEMBER { myProp } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"myProp"}, .F. ); _HB_MEMBER New( myProp); oClass:AddMethod( "New", @PostCode_New(), nScope + iif( .F., 8, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ) ); oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS PostCode ; static FUNCTION PostCode_New( myProp ) ; local Self AS CLASS PostCode := QSelf() AS CLASS PostCode; ::myProp := myProp; return Self;;

CLASS Address =; DATA;; static FUNCTION PostCode_New( ) ; local Self AS CLASS PostCode := QSelf() AS CLASS PostCode; oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS PostCode ; METHOD New() CLASS Address =; :: :=; return Self; CLASS; _HB_MEMBER { myProp } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"myProp"}, .F. ); static FUNCTION PostCode_New( myProp ) ; local Self AS CLASS PostCode := QSelf() AS CLASS PostCode; oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS PostCode ; METHOD New(myProp) CLASS; ::myProp := myProp; return Self;;
   | US of USAddress
   | UK of UKAddress
CLASS Person =; DATA;; static FUNCTION PostCode_New( ) ; local Self AS CLASS PostCode := QSelf() AS CLASS PostCode; oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS PostCode ; METHOD New() CLASS Person =; :: :=; return Self; CLASS; _HB_MEMBER { myProp } ; oClass:AddMultiData(,, nScope + iif( .F., 16, 0 ) + iif( .F., 256, 0 ) + iif( .F., 2048, 0 ), {"myProp"}, .F. ); static FUNCTION PostCode_New( myProp ) ; local Self AS CLASS PostCode := QSelf() AS CLASS PostCode; oClass:Create() ; ; ALWAYS ; __clsUnlockDef( @s_oClass, oClass ) ; end ; oInstance := oClass:Instance() ; IF __objHasMsg( oInstance, "InitClass" ) ; oInstance:InitClass( ... ) ; END ; RETURN oInstance ; END ; RETURN s_oClass:Instance() AS CLASS PostCode ; METHOD New(myProp) CLASS; ::myProp := myProp; return Self;;
   Name of string; Address of Address

let alice =
   Name="Alice"
   Address=US Street "123 Main" City "LA" State "CA" Zip "91201"
let bob =
   Name="Bob"
   Address=UK Street "221b Baker St" Town "London" PostCode="NW1 6XE"

PROCEDURE Main()



    compiler_should_raise_error_on_invalid_case()
return



function compiler_should_raise_error_on_invalid_case(employee)











    do case
 case typeof(my_payment,"MONEY")
            QOut( "MONEY" )
 case typeof(my_payment,"MONEY") .AND. my_payment:value > 0
            QOut( "MONEY .and. my_payment:value > 0" )
 case INVALID_PAYMENT

 case typeof(my_payment,"CREDIT_CARD") .AND. my_payment:value > 0
            QOut( "CREDIT_CARD .and. my_payment:value > 0" )
    endcase
return nil
